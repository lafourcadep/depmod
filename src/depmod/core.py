from __future__ import annotations

import pathlib

import numpy as np

import depmod
from depmod._lib import exastamp_generate_box_data, lammps_generate_box_data
from depmod.deformation import DeformationPath
from depmod.log import logger
from depmod.maths import fit_n_order_polynomial_with_fixed_offset
from depmod.units import convert, lammps_unit
from depmod.utils import mkopen, mkparent

ArrayLike = np._typing.ArrayLike
NDarray = np._typing.NDArray
Path = pathlib.Path
double = float
size_t = int


DEPMOD_TIME_UNIT = "s"
BUF_INDEX_H = slice(2, 11)
BUF_INDEX_G = slice(11, 20)
BUF_INDEX_F = slice(20, 29)

HEADER_STRING = """\
# Auto-generated by DEformation Path for Molecular Dynamics (DEPMOD)
#   - version %s
#   - date    %s
# ---------------------------------------- #
# DEPMOD - START LAMMPS DEFORMATION MODULE
# ---------------------------------------- #\
"""

FOOTER_STRING = """\
# ---------------------------------------- #
# DEPMOD - END LAMMPS DEFORMATION MODULE
# ---------------------------------------- #\
"""


def save_box_evolution_data(filename: str | Path | None, buffer: ArrayLike):
    if filename is not None:
        mkparent(filename)
        hstr = ",".join([f"H_{i:d}{j:d}" for i in range(1, 4) for j in range(1, 4)])
        gstr = ",".join([f"G_{i:d}{j:d}" for i in range(1, 4) for j in range(1, 4)])
        fstr = ",".join([f"F_{i:d}{j:d}" for i in range(1, 4) for j in range(1, 4)])
        np.savetxt(filename, buffer, header="index,t_ns," + hstr + gstr + fstr, delimiter=",", comments="", fmt="%.20e")
        logger.info(f"Box evolution data saved to : {filename}")


class lammps:
    TRIU_INDS = (np.array([0, 1, 2, 1, 0, 0]), np.array([0, 1, 2, 2, 2, 1]))
    TRIU_INDS_FLAT = np.array([0, 4, 8, 5, 2, 1])  # lx, ly, lz, yz, xz, xy

    @staticmethod
    def generate_box_evolution_data(
        lattice: ArrayLike,
        deformation: DeformationPath | list[DeformationPath],
        zaxis: ArrayLike | None = None,
        filename: str | None = None,
    ) -> NDarray:

        logger.info("Start generatation of LAMMPS box evolution data")

        lattice = np.array(lattice, dtype=np.float64)
        if not np.allclose(lattice, np.triu(lattice)):
            raise ValueError()

        zaxis = zaxis or (0, 0, 1)
        zaxis = np.array(zaxis, dtype=np.float64)
        if not len(zaxis) == 3:
            raise ValueError()

        if isinstance(deformation, DeformationPath):
            deformation = [deformation, ]

        logger.info(f"Chain of {len(deformation):d} deformation path.")

        # Initialize empty array python side to avoid copy back from c++ to python
        buffer_size = 1 + sum([x.npts() for x in deformation])
        buffer = np.zeros((buffer_size, 29), dtype=np.float64)
        # set initial values
        buffer[0, BUF_INDEX_H] = lattice.flatten(order="C")
        buffer[0, BUF_INDEX_G] = lattice.flatten(order="C")
        buffer[0, BUF_INDEX_F] = np.eye(3).flatten(order="C")

        logger.info(f"Initialized buffer ({buffer_size}x{29})")

        buffer_offset = 0
        for deformation_path in deformation:
            lammps_generate_box_data(deformation_path, buffer, buffer_offset)
            buffer_offset += deformation_path.npts()

        logger.info("Generation of box data completed")

        save_box_evolution_data(filename, buffer)

        return buffer

    @staticmethod
    def write_deformation_module(
        box_data: NDarray, units: str = "metal", mod_file: str = "lmp_fix_deform.mod", fix_deform_step: size_t = 1
    ) -> None:
        """Write LAMMPS 'fix deform' by part"""

        ts, lx, ly, lz, yz, xz, xy = box_data.T[(1, *(2 + lammps.TRIU_INDS_FLAT)), :]
        t = ts * convert("s", lammps_unit("time", usys=units))
        dir_label = ["x", "y", "z", "yz", "xz", "xy"]

        tfac = 1.0  # coefficients are in lammps units

        prefix = "dmpd"
        var_step_rst = f"{prefix}_step_rst"
        var_time_rst = f"{prefix}_trst"
        var_time = f"{prefix}_t"
        var_time_max = f"{prefix}_tmax"

        var_tspline = f"{prefix}_tspline"
        var_nrst = f"{prefix}_nrst"
        var_jump_end = f"{prefix}_label_end"

        str_block_header = [
            HEADER_STRING % (depmod.__version__, logger.now()),
            "variable %-20s equal $(step) # Number of step at restart (0 if fresh start)" % var_step_rst,
            "variable %-20s equal $(%.5e * dt * v_%s) # time at restart" % (var_time_rst, tfac, var_step_rst),
            "variable %-20s equal %.5e*step*dt" % (var_time, tfac),
            "variable %-20s equal $(%.5e*%.10e)" % (var_time_max, tfac, t[-1]),
        ]

        str_block_global_var = []
        str_block_conditional = []
        str_block_spline = []

        npts = int(ts.shape[0])
        nspline = npts - 1

        for n in range(0, nspline):
            t_start = t[n]
            t_end = t[n + 1]

            var_t_start = f"{prefix}_tstart_{n}"
            var_t_end = f"{prefix}_tend_{n}"
            var_index = f"{prefix}_spline_{n}"
            var_jump_label = f"{prefix}_label_spline_{n}"
            var_runstep = f"{prefix}_runstep_{n}"

            fix_deform = f"{prefix}_fix_deform_spline_{n}"

            str_block_global_var.append("variable %-20s equal % .15f" % (var_t_start, t_start))
            str_block_global_var.append("variable %-20s equal % .15f" % (var_t_end, t_end))
            str_block_global_var.append("variable %-20s equal % d" % (var_index, n))

            str_block_conditional.append(
                'if "${%s} >= ${%s} && ${%s} < ${%s}" then &' % (var_time, var_t_start, var_time, var_t_end)
            )
            str_block_conditional.append('\t"variable %s equal ${%s}" &' % (var_tspline, var_t_start))
            str_block_conditional.append('\t"variable %s equal $(v_%s)" &' % (var_nrst, var_index))
            str_block_conditional.append('\t"jump SELF %s"' % (var_jump_label))

            fix_deform_str = f"fix {fix_deform} all deform {fix_deform_step:d} "

            str_block_spline.append("# Spline %d" % n)
            str_block_spline.append("label %s" % var_jump_label)

            for label, data in zip(dir_label, [lx, ly, lz, yz, xz, xy]):
                # s_n = (lx[n + 1] - lx[n]) / (t_end - t_start)

                s_n = (data[n + 1] - data[n]) / (t_end - t_start)
                var_s_n = f"{prefix}_s{label}_{n}"

                var_change = f"{prefix}_change_{label}_{n}"
                var_rate = f"{prefix}_rate_{label}_{n}"
                var_shift = f"{prefix}_shift_{label}_{n}"
                var_corr = f"{prefix}_corr_{label}_{n}"

                str_block_global_var.append("variable %-20s equal % .15f" % (var_s_n, s_n))

                if_rst = '"variable %s equal $(v_%s*(v_%s-v_%s))"' % (var_corr, var_s_n, var_time_rst, var_tspline)
                else_rst = '"variable %s equal 0.0"' % (var_corr)
                cond = 'if "${%s} == ${%s}" then %s else %s' % (var_index, var_nrst, if_rst, else_rst)

                shift = "v_%s*v_%s+v_%s" % (var_s_n, var_t_start, var_corr)
                change = "v_%s*v_%s" % (var_s_n, var_time)
                rate = "v_%s" % (var_s_n)

                fix_deform_str += f"{label} variable v_{var_change} v_{var_rate} "

                str_block_spline.append("%s" % cond)
                str_block_spline.append("variable %s equal $(%s)" % (var_shift, shift))
                str_block_spline.append('variable %s equal "%s-v_%s"' % (var_change, change, var_shift))
                str_block_spline.append('variable %s equal "%s"' % (var_rate, rate))

            str_block_spline.append(fix_deform_str + "remap x flip no")
            str_block_spline.append("variable %s equal $(floor(v_%s/dt))" % (var_runstep, var_t_end))
            str_block_spline.append("run ${%s} upto" % (var_runstep))
            str_block_spline.append(f"unfix {fix_deform}")

        str_block_conditional.append('if "${%s} >= ${%s}" then "jump SELF %s"' % (var_time, var_time_max, var_jump_end))
        str_block_spline.append("label %s" % var_jump_end)
        str_block_spline.append(FOOTER_STRING)

        # print("\n".join(str_block_header + str_block_global_var + str_block_conditional + str_block_spline))
        with mkopen(mod_file, "w") as f:
            for block in [str_block_header, str_block_global_var, str_block_conditional, str_block_spline]:
                f.write("\n".join(block) + "\n")

        logger.info(f"LAMMPS deformation module saved to: {mod_file}")

    @staticmethod
    def write_deformation_module_poly3(
        box_data: NDarray,
        units: str = "metal",
        mod_file: str = "lmp_fix_deform.mod",
        poly_order: int = 3,
        fix_deform_step: int = 1,
        fit_file: str | None = None,
        poly_file: str | None = None,
    ) -> None:
        """Write the LAMMPS 'fix deform' module of the given time evolution of the box parameters."""
        ts, lx, ly, lz, yz, xz, xy = box_data.T[(1, *(2 + lammps.TRIU_INDS_FLAT)), :]
        t = ts * convert("s", lammps_unit("time", usys=units))
        dir_label = ["x", "y", "z", "yz", "xz", "xy"]
        poly_coeffs = {
            label: fit_n_order_polynomial_with_fixed_offset(t, data - data[0])
            for (label, data) in zip(dir_label, [lx, ly, lz, yz, xz, xy])
        }

        # tfac = convert(lammps_unit("time", usys=units), DEPMOD_TIME_UNIT)
        tfac = 1.0  # coefficients are fitted in lammps units

        str_acc = [
            "# --------------------------------",
            "# LAMMPS DEFORMATION MODULE",
            f"# AUTO GENERATED BY DEPMOD v{depmod.__version__}",
            "# --------------------------------",
            "change_box all triclinic",
            "variable t_ref_lmp equal $(step) # Time offset in lammps units",
            f"variable t_ref_dpmd equal $({tfac:.5e} * dt * v_t_ref_lmp) # Time offset in depmod units",
            f"variable t_dpmd equal {tfac:.5e}*step*dt # Time in depmod units",
        ]

        fix_deform_str = f"fix deform all deform {fix_deform_step:d} "

        for label in dir_label:
            fix_deform_str += f"{label} variable v_change_{label} v_rate_{label} "

            # write polynomial coefficients
            str_acc.append(f"\n# {label}")

            shift = []
            change = []
            rate = []

            coeff = poly_coeffs[label]

            for i in range(poly_order):
                order = i + 1
                cname = f"c{label}{order}"
                vname = f"v_{cname}"

                str_acc.append(f"variable {cname} equal {coeff[i]: .20e}")

                a = "" if order <= 1 else f"^{order}"
                b = "" if i <= 1 else f"^{i}"
                c = "" if i == 0 else "*v_t_dpmd"
                d = "" if order <= 1 else f"{order}*"

                change.append(f"{vname}*v_t_dpmd{a}")
                shift.append(f"{vname}*v_t_ref_dpmd{a}")
                rate.append(f"{d}{vname}{c}{b}")

            str_acc.append(f"variable shift_{label}  equal $(" + " + ".join(shift) + ")")
            str_acc.append(f'variable change_{label} equal "' + " + ".join(change) + f' - v_shift_{label}"')
            str_acc.append(f'variable rate_{label}   equal "' + " + ".join(rate) + '"')

        str_acc.append("\n# fix deform")
        str_acc.append(fix_deform_str + "remap x flip no")
        str_acc.append("# --------------------------------")
        str_acc.append("# END OF LAMMPS DEFORMATION MODULE")
        str_acc.append("# --------------------------------")

        with mkopen(mod_file, "w") as f:
            f.write("\n".join(str_acc))

        # dump the polynomial coefficients
        if poly_file is not None:
            # logger.warning("Save polynomial coefficients to: %s", poly_file)
            # Coeffs are stored as column.
            poly_ = np.array([poly_coeffs[label] for label in dir_label], dtype=np.float64).T
            mkparent(poly_file)
            np.savetxt(poly_file, poly_, header=",".join(dir_label), delimiter=",", comments="")

        # dump the result of the fit
        if fit_file is not None:
            data_fit = np.zeros((t.shape[0], 8 + 6), dtype=np.float64)
            data_fit[:, 0] = range(t.shape[0])
            data_fit[:, 1] = t

            for i, (label, offset) in enumerate(zip(dir_label, [lx, ly, lz, yz, xz, xy]), start=2):
                data_fit[:, i] = np.polynomial.Polynomial((0.0, *poly_coeffs[label]))(t)
                data_fit[:, i + 6] = data_fit[:, i] + offset[0]

            mkparent(fit_file)
            np.savetxt(
                fit_file,
                data_fit,
                header="index,t,dlx,dly,dlz,dyz,dxz,dxy,lx,ly,lz,yz,xz,xy",
                delimiter=",",
                comments="",
            )


class exastamp:
    @staticmethod
    def generate_box_evolution_data(deformation: DeformationPath, filename: str | None = None) -> NDarray:
        I33 = np.eye(3)
        buffer = np.zeros((deformation.npts() + 1, 29), dtype=np.float64)

        # set initial values
        buffer[0, 2:11] = I33.flatten(order="C")
        buffer[0, 11:20] = I33.flatten(order="C")
        buffer[0, 20:29] = I33.flatten(order="C")

        exastamp_generate_box_data(deformation, buffer)
        save_box_evolution_data(filename, buffer)

        return buffer

    @staticmethod
    def write_deformation_module(
        data: NDarray,
        mod_file: str = "deform.cfg",
        indent: int = 2,
        time_fmt: str = "% 5.3f",
        xform_fmt: str = "%20.10e",
        units: str = "ps",
    ) -> None:
        """Write the EXASTAMP 'deform.cfg' module of the given time evolution of F.

        Parameters
        ----------

        Returns
        -------
        None

        """

        xindent = " " * int(indent)
        time_serie = data[:, 1] * convert(DEPMOD_TIME_UNIT, units)
        xform_serie = data[:, 20:29].flatten(order="C")  # only care about F(t)

        n = len(time_serie)

        time_str = ",".join([time_fmt % t for t in time_serie])

        xform_key = f"{xindent}xform_serie: [ "
        xxindent = " " * len(xform_key)

        xform_str = f"{xform_key}[%s],\n" + (f"{xxindent}[%s],\n" * (n - 2)) + f"{xxindent}[%s] ]\n\n"
        xform_line = ", ".join(["[ %s ]" % (", ".join([xform_fmt] * 3))] * 3)

        str_acc = [
            "xform_time_iterpolate_byparts:",
            f"{xindent}time_serie: [ {time_str} ]",
            (xform_str % tuple([xform_line] * n)) % tuple(xform_serie),
        ]

        with mkopen(mod_file, "w") as f:
            f.write("\n".join(str_acc))


# Some shorter alias
lmp = lammps
xsp = exastamp
