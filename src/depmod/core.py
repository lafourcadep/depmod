from __future__ import annotations

import numpy as np

from ._lib import exastamp_generate_box_data, lammps_generate_box_data
from .deformation import DeformationPath
from .maths import fit_n_order_polynomial_with_fixed_offset
from .units import convert, lammps_unit
from .utils import mkopen, mkparent

ArrayLike = np._typing.ArrayLike
ndarray = np.ndarray


DEPMOD_TIME_UNIT = "s"


def save_box_evolution_data(filename, buffer):
    if filename is not None:
        mkparent(filename)
        hstr = ",".join([f"H_{i:d}{j:d}" for i in range(1, 4) for j in range(1, 4)])
        gstr = ",".join([f"G_{i:d}{j:d}" for i in range(1, 4) for j in range(1, 4)])
        fstr = ",".join([f"F_{i:d}{j:d}" for i in range(1, 4) for j in range(1, 4)])
        np.savetxt(filename, buffer, header="index,t_ns," + hstr + gstr + fstr, delimiter=",", comments="")


class lammps:
    TRIU_INDS = (np.array([0, 1, 2, 1, 0, 0]), np.array([0, 1, 2, 2, 2, 1]))
    TRIU_INDS_FLAT = np.array([0, 4, 8, 5, 2, 1])  # lx, ly, lz, yz, xz, xy

    def generate_box_evolution_data(
        lattice: ArrayLike,
        deformation: DeformationPath,
        zaxis: ArrayLike | None = None,
        filename: str | None = None,
    ):
        lattice = np.array(lattice, dtype=np.float64)
        assert np.allclose(lattice, np.triu(lattice))

        zaxis = zaxis or (0, 0, 1)
        zaxis = np.array(zaxis, dtype=np.float64)
        assert len(zaxis) == 3

        # Initialize empty array python side to avoid copy back from c++ to python
        #  0     index
        #  1     time
        #  2:10  H(t)
        # 11:19  G(t)
        # 20:28  F(t)
        buffer = np.zeros((deformation.npts() + 1, 29), dtype=np.float64)

        # set initial values
        buffer[0, 2:11] = lattice.flatten(order="C")
        buffer[0, 11:20] = lattice.flatten(order="C")
        buffer[0, 20:29] = np.eye(3).flatten(order="C")

        lammps_generate_box_data(deformation, buffer)
        save_box_evolution_data(filename, buffer)

        return buffer

    def write_deformation_module(
        box_data: ndarray,
        units: str = "metal",
        mod_file: str = "lmp_fix_deform.mod",
        poly_order: int = 3,
        fix_deform_step: int = 1,
        fit_file: str | None = None,
        poly_file: str | None = None,
    ) -> None:
        """Write the LAMMPS 'fix deform' module of the given time evolution of the box parameters."""
        ts, lx, ly, lz, yz, xz, xy = box_data.T[(1, *(2 + lammps.TRIU_INDS_FLAT)), :]
        t = ts * convert("s", lammps_unit("time", usys=units))
        dir_label = ["x", "y", "z", "yz", "xz", "xy"]
        poly_coeffs = {
            label: fit_n_order_polynomial_with_fixed_offset(t, data - data[0])
            for (label, data) in zip(dir_label, [lx, ly, lz, yz, xz, xy])
        }

        # tfac = convert(lammps_unit("time", usys=units), DEPMOD_TIME_UNIT)
        tfac = 1 # coefficients are fitted in lammps units
        str_acc = [
            "# --------------------------------",
            "# LAMMPS DEFORMATION MODULE",
            # f"# AUTO GENERATED BY DEPMOD v{depmod.__version__}",
            "# --------------------------------",
            "change_box all triclinic",
            "variable t_ref_lmp equal $(step) # Time offset in lammps units",
            f"variable t_ref_dpmd equal $({tfac:.5e} * dt * v_t_ref_lmp) # Time offset in depmod units",
            f"variable t_dpmd equal {tfac:.5e}*step*dt # Time in depmod units"
        ]

        fix_deform_str = f"fix deform all deform {fix_deform_step:d} "

        for label in dir_label:
            fix_deform_str += f"{label} variable v_change_{label} v_rate_{label} "

            # write polynomial coefficients
            str_acc.append(f"\n# {label}")

            shift = []
            change = []
            rate = []

            coeff = poly_coeffs[label]

            for i in range(poly_order):
                order = i + 1
                cname = f"c{label}{order}"
                vname = f"v_{cname}"

                str_acc.append(f"variable {cname} equal {coeff[i]: .20f}")

                a = "" if order <= 1 else f"^{order}"
                b = "" if i <= 1 else f"^{i}"
                c = "" if i == 0 else "*v_t_dpmd" 
                d = "" if order <= 1 else f"{order}*"

                change.append(f"{vname}*v_t_dpmd{a}")
                shift.append(f"{vname}*v_t_ref_dpmd{a}")
                rate.append(f"{d}{vname}{c}{b}")

            str_acc.append(f"variable shift_{label}  equal $("+" + ".join(shift)+")")
            str_acc.append(f"variable change_{label} equal \""+" + ".join(change)+f" - v_shift_{label}\"")
            str_acc.append(f"variable rate_{label}   equal \""+" + ".join(rate)+"\"")

        str_acc.append("\n# fix deform")
        str_acc.append(fix_deform_str + "remap x flip no")
        str_acc.append("# --------------------------------")
        str_acc.append("# END OF LAMMPS DEFORMATION MODULE")
        str_acc.append("# --------------------------------")

        with mkopen(mod_file, "w") as f:
            f.write("\n".join(str_acc))

        # dump the polynomial coefficients
        if poly_file is not None:
            # logger.warning("Save polynomial coefficients to: %s", poly_file)
            # Coeffs are stored as column.
            poly_ = np.array([poly_coeffs[label] for label in dir_label], dtype=np.float64).T
            mkparent(poly_file)
            np.savetxt(poly_file, poly_, header=",".join(dir_label), delimiter=",", comments="")

        # dump the result of the fit
        if fit_file is not None:
            data_fit = np.zeros((t.shape[0], 8 + 6), dtype=np.float64)
            data_fit[:, 0] = range(t.shape[0])
            data_fit[:, 1] = t

            for i, (label, offset) in enumerate(zip(dir_label, [lx, ly, lz, yz, xz, xy]), start=2):
                data_fit[:, i] = np.polynomial.Polynomial((0.0, *poly_coeffs[label]))(t)
                data_fit[:, i + 6] = data_fit[:, i] + offset[0]

            mkparent(fit_file)
            np.savetxt(
                fit_file,
                data_fit,
                header="index,t,dlx,dly,dlz,dyz,dxz,dxy,lx,ly,lz,yz,xz,xy",
                delimiter=",",
                comments="",
            )


class exastamp:
    def generate_box_evolution_data(deformation: DeformationPath, filename: str | None = None):
        I33 = np.eye(3)
        buffer = np.zeros((deformation.npts() + 1, 29), dtype=np.float64)

        # set initial values
        buffer[0, 2:11] = I33.flatten(order="C")
        buffer[0, 11:20] = I33.flatten(order="C")
        buffer[0, 20:29] = I33.flatten(order="C")

        exastamp_generate_box_data(deformation, buffer)
        save_box_evolution_data(filename, buffer)

        return buffer

    def write_deformation_module(
        data: ndarray,
        mod_file: str = "deform.cfg",
        indent: int = 2,
        time_fmt: str = "% 5.3f",
        xform_fmt: str = "%20.10e",
        units: str = "ps"
    ) -> None:
        """Write the EXASTAMP 'deform.cfg' module of the given time evolution of F.

        Parameters
        ----------

        Returns
        -------
        None

        """

        xindent = " " * int(indent)
        time_serie = data[:, 1] * convert(DEPMOD_TIME_UNIT, units)
        xform_serie = data[:, 20:29].flatten(order="C") # only care about F(t)

        n = len(time_serie)

        time_str = ",".join([time_fmt % t for t in time_serie])

        xform_key = f"{xindent}xform_serie: [ "
        xxindent = " " * len(xform_key)

        xform_str = f"{xform_key}[%s],\n" + (f"{xxindent}[%s],\n" * (n - 2)) + f"{xxindent}[%s] ]\n\n"
        xform_line = ", ".join(["[ %s ]" % (", ".join([xform_fmt] * 3))] * 3)

        str_acc = [
            "xform_time_iterpolate_byparts:",
            f"{xindent}time_serie: [ {time_str} ]",
            (xform_str % tuple([xform_line] * n)) % tuple(xform_serie)
        ]

        with mkopen(mod_file, "w") as f:
            f.write("\n".join(str_acc))


lmp = lammps
xsp = exastamp
