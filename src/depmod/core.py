"""???
"""
from __future__ import annotations

import numpy as np

import depmod

from depmod.config import Config
from depmod.deformation import Deformation
from depmod.log import logger
from depmod.maths import fit_n_order_polynomial_with_fixed_offset
from depmod.typing import ArrayLike, ndarray
from depmod.units import convert, lammps_unit
from depmod.io import mkopen, mkparent

from depmod._lib.core import (
    _lib_exastamp_generate_box_evolution_data,
    _lib_IntegrationMethod,
    _lib_lammps_generate_box_evolution_data
)

DEPMOD_TIME_UNIT = "ns"

def get_integration_method(method: str) -> _lib_IntegrationMethod:
    """Return the integration method from a string.
    
    Parameters
    ----------
    method: str
        Name of the integration method.

    """
    avail_methods = {
        "brute": _lib_IntegrationMethod.BRUTE,
        "center": _lib_IntegrationMethod.CENTER,
        "bruzy": _lib_IntegrationMethod.BRUZY
    }

    if method not in avail_methods:
        raise KeyError(
            f"Method '{method}' is not valid. "
            f"Supported methods are: {', '.join(avail_methods.keys())}."
        )

    if method in ("center", "bruzy", ):
        raise NotImplementedError("¯\_(ツ)_/¯")

    return avail_methods[method]


def lammps_generate_box_evolution_data(
    H: ndarray,
    config: Config,
    deform: Deformation,
    zaxis: ArrayLike | None = None,
    filename: str | None = None,
    method: str = "brute"
) -> ndarray:
    """Generate the time evolution of the box parameters given a configuration and a deformation.

    Parameters
    ----------

    Returns
    -------
    ndarray

    """
    
    # Undeformed lattice. Check if it's upper triangular.
    H = np.array(H, dtype=np.float64)
    assert np.allclose(H, np.triu(H))

    # Define z-axis
    # TODO: Make this actually relevent
    if zaxis is None:
        zaxis = (0, 0, 1)
    zaxis = np.array(zaxis, dtype=np.float64)

    # Initialize empty array python side to avoid copy back from c++ to python
    t  = np.zeros((config.N + 1, ), dtype=np.float64)
    Ht = np.zeros((config.N + 1, 9), dtype=np.float64) 
    Gt = np.zeros((config.N + 1, 9), dtype=np.float64)
    Ft = np.zeros((config.N + 1, 9), dtype=np.float64)

    Ht[0, :] = H.flatten(order="C")
    Gt[0, :] = Ht[0, :]
    Ft[0, :] = np.eye(3).flatten(order="C")

    _lib_lammps_generate_box_evolution_data(
        get_integration_method(method),
        config,
        deform,
        t,
        Ht,
        Gt,
        Ft
    )
    
    LAMMPS_TRIU_INDS = (np.array([0, 1, 2, 1, 0, 0]), np.array([0, 1, 2, 2, 2, 1]))
    LAMMPS_TRIU_INDS_FLAT = np.array([0, 4, 8, 5, 2, 1]) # lx, ly, lz, yz, xz, xy
    
    # Fill the outputed array
    # Swapping data using numpy is faster than doing it from c++ side.
    array_out = np.zeros((config.N + 1, 17), dtype=float)
    array_out[:, 0] = range(config.N + 1)
    array_out[:, 1] = t[:] * convert("s", DEPMOD_TIME_UNIT)
    array_out[:, 2:8] = Gt[:, LAMMPS_TRIU_INDS_FLAT] 
    array_out[:, 8:] = Ft[:, :]

    # Write the array to file if required
    if filename is not None:
        logger.info(f"Saving box data to: \"{filename}\"")
        mkparent(filename)
        np.savetxt(
            filename,
            array_out,
            header="index,t_ns,lx,ly,lz,yz,xz,xy,"+ ",".join([f"F_{i:d}" for i in range(9)]),
            delimiter=",",
            comments=""
        )

    return array_out


def lammps_write_deformation_module(
    box_data: ndarray,
    units: str = "metal",
    mod_file: str = "lmp_fix_deform.mod",
    poly_order: int = 3,
    fix_deform_step: int = 1,
    fit_file: str | None = None,
    poly_file: str | None = None,
) -> None:
    """Write the LAMMPS 'fix deform' module of the given time evolution of the box parameters.

    Parameters
    ----------

    Returns
    -------
    None

    """
    
    tns = box_data[:, 1]
    lx = box_data[:, 2]
    ly = box_data[:, 3]
    lz = box_data[:, 4]
    yz = box_data[:, 5]
    xz = box_data[:, 6]
    xy = box_data[:, 7]

    dir_label = ["x", "y", "z", "yz", "xz", "xy"]
    
    poly_coeffs = {}

    logger.info("Fitting polynomial coefficients (order = %d)", poly_order)
    for label, dir_data in zip(dir_label, [lx, ly, lz, yz, xz, xy]):
        poly_coeffs[label] = fit_n_order_polynomial_with_fixed_offset(tns, dir_data - dir_data[0], n=poly_order)

    # write lammps module
    logger.info(f"Writing LAMMPS fix deform module: '{mod_file}'")
    tfac = convert(lammps_unit("time", usys=units), DEPMOD_TIME_UNIT)

    str_acc = [
        "# --------------------------------",
        "# LAMMPS DEFORMATION MODULE",
        f"# AUTO GENERATED BY DEPMOD v{depmod.__version__}",
        "# --------------------------------",
        "change_box all triclinic",
        "variable t_ref_lmp equal $(step) # Time offset in lammps units",
        f"variable t_ref_dpmd equal $({tfac:.5e} * dt * v_t_ref_lmp) # Time offset in depmod units",
        f"variable t_dpmd equal {tfac:.5e}*step*dt # Time in depmod units"
    ]

    fix_deform_str = f"fix deform all deform {fix_deform_step:d} "

    for label in dir_label:
        fix_deform_str += f"{label} variable v_change_{label} v_rate_{label} "

        # write polynomial coefficients
        str_acc.append(f"\n# {label}")

        shift = []
        change = []
        rate = []

        coeff = poly_coeffs[label]

        for i in range(poly_order):
            order = i + 1
            cname = f"c{label}{order}"
            vname = f"v_{cname}"

            str_acc.append(f"variable {cname} equal {coeff[i]: .20f}")

            a = "" if order <= 1 else f"^{order}"
            b = "" if i <= 1 else f"^{i}"
            c = "" if i == 0 else "*v_t_dpmd" 
            d = "" if order <= 1 else f"{order}*"

            change.append(f"{vname}*v_t_dpmd{a}")
            shift.append(f"{vname}*v_t_ref_dpmd{a}")
            rate.append(f"{d}{vname}{c}{b}")

        str_acc.append(f"variable shift_{label}  equal $("+" + ".join(shift)+")")
        str_acc.append(f"variable change_{label} equal \""+" + ".join(change)+f" - v_shift_{label}\"")
        str_acc.append(f"variable rate_{label}   equal \""+" + ".join(rate)+"\"")

    str_acc.append("\n# fix deform")
    str_acc.append(fix_deform_str + "remap x flip no")
    str_acc.append("# --------------------------------")
    str_acc.append("# END OF LAMMPS DEFORMATION MODULE")
    str_acc.append("# --------------------------------")

    with mkopen(mod_file, "w") as f:
        f.write("\n".join(str_acc))

    # dump the polynomial coefficients
    if poly_file is not None:
        logger.warning("Save polynomial coefficients to: %s", poly_file)
        
        # Coeffs are stored as column. Why ???
        poly_ = np.array([poly_coeffs[label] for label in dir_label], dtype=np.float64).T

        mkparent(poly_file)
        np.savetxt(
            poly_file,
            poly_,
            header=",".join(dir_label),
            delimiter=",",
            comments="",
        )

    # dump the result of the fit
    if fit_file is not None:
        logger.info("Save fit results to: %s", fit_file)

        data_fit = np.zeros((tns.shape[0], 8), dtype=np.float64)

        data_fit[:, 0] = range(tns.shape[0])
        data_fit[:, 1] = tns

        for i, label in enumerate(dir_label, start=2):
            data_fit[:, i] = np.polynomial.Polynomial((0., *poly_coeffs[label]))(tns)

        mkparent(fit_file)
        np.savetxt(
            fit_file,
            data_fit,
            header="index,t_ns,lx,ly,lz,yz,xz,xy",
            delimiter=",",
            comments=""
        )


def lammps_write_deformation_module_v2() -> None:
    raise NotImplementedError("¯\_(ツ)_/¯")


def exastamp_generate_box_evolution_data(
    config: Config,
    deform: Deformation,
    method: str = "brute",
    filename: str | None = None,
) -> ndarray:
    """Generate the time evolution of deformation gradient tensor.

    For exaStamp we only need to compute the time evolution of F.
    
    Parameters
    ----------

    Returns
    -------
    None

    """
    t  = np.zeros((config.N + 1, ), dtype=np.float64)
    Ft = np.zeros((config.N + 1, 9), dtype=np.float64) 

    Ft[0, :] = np.eye(3).flatten(order="C")

    _lib_exastamp_generate_box_evolution_data(
        get_integration_method(method),
        config,
        deform,
        t,
        Ft
    )
    
    array_out = np.zeros((config.N + 1, 2+9), dtype=np.float64)
    array_out[:, 0] = range(config.N + 1)
    array_out[:, 1] = t[:] * convert("s", DEPMOD_TIME_UNIT)
    array_out[:, 2:] = Ft[:, :]

    # Write the array to file if required
    if filename is not None:
        mkparent(filename)
        np.savetxt(
            filename,
            array_out,
            header="index,t_ns," + ",".join([f"F_{i:d}" for i in range(9)]),
            delimiter=",",
            comments=""
        )

    return array_out


def exastamp_write_deformation_module(
    data: ndarray,
    mod_file: str = "deform.cfg",
    indent: int = 2,
    time_fmt: str = "% 5.3f",
    xform_fmt: str = "%20.10e"
) -> None:
    """Write the EXASTAMP 'deform.cfg' module of the given time evolution of F.
    
    Parameters
    ----------

    Returns
    -------
    None

    """

    xindent = " " * int(indent)

    time_serie = data[:, 1] * convert(DEPMOD_TIME_UNIT, "ps")
    xform_serie = data[:, 2:].flatten(order="C")

    n = len(time_serie)

    time_str = ",".join([time_fmt % t for t in time_serie])

    xform_key = f"{xindent}xform_serie: [ "
    xxindent = " " * len(xform_key)
    
    xform_str = f"{xform_key}[%s],\n" + (f"{xxindent}[%s],\n" * (n - 2)) + f"{xxindent}[%s] ]\n\n"
    xform_line = ", ".join(["[ %s ]" % (", ".join([xform_fmt] * 3))] * 3)

    str_acc = [
        "xform_time_iterpolate_byparts:",
        f"{xindent}time_serie: [ {time_str} ]",
        (xform_str % tuple([xform_line] * n)) % tuple(xform_serie)
    ]

    with mkopen(mod_file, "w") as f:
        f.write("\n".join(str_acc))
