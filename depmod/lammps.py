from __future__ import annotations

import numpy as np

import depmod
from depmod.config import Config
from depmod.deformation import Deformation
from depmod.maths import fit_n_order_polynomial_with_fixed_offset
from depmod.typing import ArrayLike, ndarray
from depmod.units import convert, lammps_unit

# from depmod._lib.lammps import (
#     _lib_lammps_generate_box_evolution_data_brute,
# )


LAMMPS_TRIU_INDS = (np.array([0, 1, 2, 1, 0, 0]), np.array([0, 1, 2, 2, 2, 1]))
LAMMPS_TRIU_INDS_FLAT = np.array([0, 4, 8, 5, 2, 1]) # lx, ly, lz, yz, xz, xy

def generate_box_evolution_data():
    pass

def write_deformation_module():
    print(depmod.__version__)

def lammps_generate_box_evolution_data(
    H: ndarray,
    config: Config,
    deform: Deformation,
    zaxis: ArrayLike | None = None,
    filename: str | None = None,
    method: str = "brute"
) -> ndarray :

    H = np.array(H, dtype=np.float64)

    if zaxis is None:
        zaxis = (0, 0, 1)

    zaxis = np.array(zaxis, dtype=np.float64)

    # Initalize empty arrays
    t  = np.zeros((config.N+1,), dtype=np.float64)
    Ht = np.zeros((config.N+1, 9), dtype=np.float64)
    Gt = np.zeros((config.N+1, 9), dtype=np.float64)
    Ft = np.zeros((config.N+1, 9), dtype=np.float64)

    assert np.allclose(H, np.triu(H))

    Ht[0, :] = H.flatten(order="C")
    Gt[0, :] = Ht[0, :]
    Ft[0, :] = np.eye(3).flatten(order="C")


    if method == "brute":
    
        _lib_lammps_generate_box_evolution_data_brute(
            config,
            deform,
            t,
            Ht,
            Gt,
            Ft,
        )

    elif method == "centered":
        raise NotImplementedError("¯\_(ツ)_/¯")

    elif method == "bruzy":
        raise NotImplementedError("¯\_(ツ)_/¯")

    else:
        raise ValueError(f"{method} is not a valid method. Supported method are: 'brute', 'centered' and 'bruzy'.")

    array_out = np.zeros((config.N+1, 17), dtype=np.float64)
    s_to_ns = convert("s", "ns")
    
    # fill the outputed array.
    # numpy operation on array are faster that C++ implementation
    array_out[:, 0] = range(config.N + 1)
    array_out[:, 1] = t[:] * s_to_ns # convert s to ns
    array_out[:, 2:8] = Gt[:, LAMMPS_TRIU_INDS_FLAT]
    array_out[:, 8:] = Ft[:, :]

    if filename is not None:
        # Write to file
        np.savetxt(
            filename,
            array_out,
            header="index,t_ns,lx,ly,lz,yz,xz,xy," + ",".join([f"F_{i:d}" for i in range(9)]),
            delimiter=",",
            comments=""
        )

    return array_out


def lammps_write_fix_deform_module(
    box_data: np.ndarray,
    units: str = "metal",
    filename: str = "lmp_fix_deform.mod",
    dumpfit: str | None = None,
    poly_order: int = 3,
    nstep: int = 1
) -> None:
    """Write the LAMMPS fix deformation module for the associated time evolution of the box parameters.
    
    Parameters
    ----------

    Returns
    -------
    None
    """ 
    tns = box_data[:, 1]
    lx = box_data[:, 2]
    ly = box_data[:, 3]
    lz = box_data[:, 4]
    yz = box_data[:, 5]
    xz = box_data[:, 6]
    xy = box_data[:, 7]

    dir_label = ["x", "y", "z", "yz", "xz", "xy"]
    
    poly_coeffs = {}

    for label, dir_data in zip(dir_label, [lx, ly, lz, yz, xz, xy]):
        poly_coeffs[label] = fit_n_order_polynomial_with_fixed_offset(tns, dir_data - dir_data[0], n=poly_order)

    # write lammps module

    tfac = convert(lammps_unit("time", usys=units), "ns")

    str_acc = []

    str_acc.append("# LAMMPS DEFORMATION MODULE")
    str_acc.append(f"# AUTOMATICALY GENERATED BY DEPMOD v{depmod.__version__}")
    str_acc.append("change_box all triclinic")
    str_acc.append("variable t_inst equal $(step)")
    str_acc.append(f"variable t_ref_ns equal $({tfac:.5e} * dt * v_t_inst)")
    str_acc.append(f"variable tns equal {tfac:.5e}*step*dt")

    # by default nstep = 1
    fix_deform = f"fix deform all deform {nstep} "

    for label in dir_label:

        fix_deform += f"{label} variable v_change_{label} v_rate_{label} "

        # write polynomial coefficient and function
        str_acc.append(f"\n# {label}")

        shift = []
        change = []
        rate = []

        coeff = poly_coeffs[label]

        for i in range(poly_order):
            o = i + 1
            w = f"c{label}{o}"
            c = f"v_{w}"

            str_acc.append(f"variable {w} equal {coeff[i]: .20f}")

            e1 = "" if o <= 1 else f"^{o}"
            e2 = "" if i <= 1 else f"^{i}"
            v = "" if i == 0 else "*v_tns"
            k = "" if o <= 1 else f"{o}*"

            change.append(f"{c}*v_tns{e1}")
            shift.append(f"{c}*v_t_ref_ns{e1}")
            rate.append(f"{k}{c}{v}{e2}")

        str_acc.append(f"variable shift_{label}  equal $("+" + ".join(shift)+")")
        str_acc.append(f"variable change_{label} equal \""+" + ".join(change)+f" - v_shift_{label}\"")
        str_acc.append(f"variable rate_{label}   equal \""+" + ".join(rate)+"\"")

    str_acc.append("\n# FIX DEFORM")
    str_acc.append(fix_deform + "remap x flip no")
    str_acc.append("# END OF DEFORMATION MODULE FILE")

    with open(filename, "w") as f:
        f.write("\n".join(str_acc))

    if dumpfit is not None:
        data_fit = np.zeros((tns.shape[0], 8), dtype=np.float64)
        data_fit[:, 0] = range(tns.shape[0])
        data_fit[:, 1] = tns

        for i, label in enumerate(dir_label, start=2):
            # data_fit[:, i] = third_order_polynomial(t_ns, *c)
            data_fit[:, i] = np.polynomial.Polynomial((0., *poly_coeffs[label]))(tns)

        np.savetxt(
            dumpfit,
            data_fit,
            header="index,t_ns,lx,ly,lz,yz,xz,xy",
            delimiter=",",
            comments=""
        )

    return None
